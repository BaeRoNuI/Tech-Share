# 이벤트 기반 아키텍처 (Event-Driven Architecture)
이벤트 기반 아키텍처(Event-Driven Architecture)는 `회원 가입`, `결제 완료`, `주문 취소`와 같은 도메인 이벤트를 메시지 브로커를 통해 발행(Publish)·구독(Subscribe)하여, 서비스 간 직접 의존성을 최소화하고 비동기적으로 상호 작용하도록 구성하는 분산 시스템 설계 패턴이다.

마이크로서비스 아키텍처(MSA)와 자주 함께 언급되지만 관점이 다르다.

- **마이크로 서비스 아키텍처 (MSA)**
	- 애플리케이션을 작게 나누어 독립적으로 배포·운영한다.
	- 시스템 구성 패턴
- **이벤트 기반 아키텍처 (EDA)**
	- 이벤트를 매개로 서비스들이 메시지 브로커를 통해 느슨하게 연결된다.
	- 통신 패턴

현대적인 MSA 환경에서는 서비스 간 직접 호출이 증가할수록 장애 전파와 배포 난이도가 급격히 올라가므로, EDA를 도입해 이벤트 중심 통신으로 전환하는 사례가 많다.

# EDA에서의 동기 작업
이벤트 기반 시스템은 기본적으로 비동기로 동작하지만, 업무 요건에 따라 애플리케이션 간 **동기적 보장**이 필요한 구간이 생긴다. 

아래 예시는 이를 설명하기 위한 가상의 시나리오다.
(이해를 돕기 위해 만든 시나리오라, 현실성이 다소 떨어질 수 있음을 참고 바란다)

## 시나리오: 자정 배치와 주문 이벤트
어떤 쇼핑몰에서는 매일 자정에 전날 주문 기록을 취합해 새벽 배송을 하는 서비스를 운영 중이다.
![](resources/Pasted%20image%2020250608034553.png)

1. **배경**
    매일 0시, 전날 주문을 집계해 새벽 배송을 준비하는 배치 프로세스가 있다.
2. **문제**  
    주문 이벤트를 Kafka로 수집해 데이터베이스에 적재하는 프로세서가 지연되면, 소비자가 자정 이전에 주문을 완료했더라도 배치 시점까지 DB 반영이 끝나지 않아 다음 날로 배송이 밀린다.
3. **목표**  
	배치 프로세스가 실행되기 전, “전날 0시까지의 모든 주문 이벤트가 DB에 반영되었다”는 사실을 검증해야 한다.

## 파티션별 진행 상태 캐싱
아래 구조는 파티션별 **처리 완료 시각**을 캐싱하여 문제를 해결하는 전형적인 방법이다.
![](resources/Pasted%20image%2020250608034536.png)

- DB Sink 프로세서가 각 파티션에서 마지막으로 처리한 이벤트의 `eventTime`을 Redis 같은 KV 저장소에 기록한다.
```
{key: order.1, timestamp: 1749319887}
{key: order.2, timestamp: 1749312123}
{key: order.2, timestamp: 1749312402}
```
- 배치 프로세스는 모든 파티션의 `lastProcessedTimestamp` 중 **가장 작은값**을 조회한다.
- 이 값은 “모든 파티션이 이 시점 이전 이벤트를 완전히 처리했다”는 하한선(barrier)을 의미한다.
- 값이 자정(0시)을 넘었으면 안전하게 집계를 시작한다.

### 왜 최소값을 보느냐?
![](resources/Pasted%20image%2020250608031320.png)
- Kafka는 **파티션 내부** 순서를 보장하지만, 여러 파티션 간에는 순서가 섞일 수 있다.
- 각 파티션이 서로 다른 시점까지 처리됐을 때, 전체 시스템이 **안전히 집계 가능한 순간**은 가장 뒤처진 파티션과 동기화된 시점이다.

### 역순 이벤트(out-of-order) 허용치 고려
- 브로커·네트워크·프로세서 지연으로 이벤트가 최대 5분 역전될 수 있다고 가정하자.
- 그렇다면 처리 보장 하한선이 0시 5분이 되어야 “전날 0시까지의 모든 주문이 처리 완료”라고 보장할 수 있다.

## 확장 시 주의할 점

- 파티션이 늘면 캐시 키 수가 선형으로 증가한다. 실시간 프로세스가 빈번히 캐시를 조회해야 한다면, 네트워크 RTT와 직렬화 비용이 병목이 된다.